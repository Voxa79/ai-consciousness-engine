apiVersion: batch/v1
kind: Job
metadata:
  name: vault-init
  namespace: vault
  labels:
    app.kubernetes.io/name: vault-init
    app.kubernetes.io/instance: vault
    app.kubernetes.io/component: security
  annotations:
    consciousness-engine.com/description: "Vault initialization and configuration job"
spec:
  template:
    metadata:
      labels:
        app.kubernetes.io/name: vault-init
        app.kubernetes.io/instance: vault
        app.kubernetes.io/component: security
    spec:
      serviceAccountName: vault
      restartPolicy: OnFailure
      securityContext:
        runAsNonRoot: true
        runAsUser: 1000
        runAsGroup: 1000
        fsGroup: 1000
        seccompProfile:
          type: RuntimeDefault
      containers:
      - name: vault-init
        image: hashicorp/vault:1.15.2
        imagePullPolicy: IfNotPresent
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
        env:
        - name: VAULT_ADDR
          value: "https://vault.vault.svc.cluster.local:8200"
        - name: VAULT_SKIP_VERIFY
          value: "true"
        command:
        - "/bin/sh"
        - "-c"
        args:
        - |
          set -e
          
          echo "Waiting for Vault to be ready..."
          until vault status > /dev/null 2>&1; do
            echo "Vault not ready, waiting..."
            sleep 5
          done
          
          echo "Checking if Vault is already initialized..."
          if vault status | grep -q "Initialized.*true"; then
            echo "Vault is already initialized"
            exit 0
          fi
          
          echo "Initializing Vault..."
          vault operator init \
            -key-shares=5 \
            -key-threshold=3 \
            -format=json > /tmp/vault-init.json
          
          echo "Vault initialized successfully"
          
          # Extract unseal keys and root token
          UNSEAL_KEY_1=$(cat /tmp/vault-init.json | jq -r '.unseal_keys_b64[0]')
          UNSEAL_KEY_2=$(cat /tmp/vault-init.json | jq -r '.unseal_keys_b64[1]')
          UNSEAL_KEY_3=$(cat /tmp/vault-init.json | jq -r '.unseal_keys_b64[2]')
          ROOT_TOKEN=$(cat /tmp/vault-init.json | jq -r '.root_token')
          
          echo "Unsealing Vault..."
          vault operator unseal $UNSEAL_KEY_1
          vault operator unseal $UNSEAL_KEY_2
          vault operator unseal $UNSEAL_KEY_3
          
          echo "Logging in with root token..."
          vault auth $ROOT_TOKEN
          
          echo "Configuring Vault for Consciousness Engine..."
          
          # Enable audit logging
          vault audit enable file file_path=/vault/logs/audit.log
          
          # Enable Kubernetes auth method
          vault auth enable kubernetes
          
          # Configure Kubernetes auth
          vault write auth/kubernetes/config \
            token_reviewer_jwt="$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)" \
            kubernetes_host="https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT" \
            kubernetes_ca_cert=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt
          
          # Enable KV v2 secrets engine for consciousness
          vault secrets enable -path=consciousness kv-v2
          
          # Enable database secrets engine
          vault secrets enable database
          
          # Enable PKI secrets engine for internal certificates
          vault secrets enable -path=pki-internal pki
          vault secrets tune -max-lease-ttl=8760h pki-internal
          
          # Generate internal CA
          vault write pki-internal/root/generate/internal \
            common_name="Consciousness Engine Internal CA" \
            ttl=8760h
          
          # Configure PKI URLs
          vault write pki-internal/config/urls \
            issuing_certificates="https://vault.consciousness-engine.com:8200/v1/pki-internal/ca" \
            crl_distribution_points="https://vault.consciousness-engine.com:8200/v1/pki-internal/crl"
          
          # Create role for consciousness services
          vault write pki-internal/roles/consciousness-services \
            allowed_domains="consciousness-engine.com,svc.cluster.local" \
            allow_subdomains=true \
            max_ttl=720h
          
          # Create policies for consciousness services
          cat > /tmp/consciousness-policy.hcl << EOF
          # Consciousness Engine Service Policy
          
          # Read consciousness secrets
          path "consciousness/data/*" {
            capabilities = ["read"]
          }
          
          # List consciousness secrets
          path "consciousness/metadata/*" {
            capabilities = ["list"]
          }
          
          # Database credentials
          path "database/creds/consciousness-db" {
            capabilities = ["read"]
          }
          
          # PKI certificates
          path "pki-internal/issue/consciousness-services" {
            capabilities = ["create", "update"]
          }
          
          # Renew own token
          path "auth/token/renew-self" {
            capabilities = ["update"]
          }
          
          # Lookup own token
          path "auth/token/lookup-self" {
            capabilities = ["read"]
          }
          EOF
          
          vault policy write consciousness-service /tmp/consciousness-policy.hcl
          
          # Create Kubernetes role for consciousness services
          vault write auth/kubernetes/role/consciousness-service \
            bound_service_account_names=consciousness-service \
            bound_service_account_namespaces=consciousness-prod,consciousness-staging \
            policies=consciousness-service \
            ttl=1h
          
          # Create admin policy
          cat > /tmp/consciousness-admin-policy.hcl << EOF
          # Consciousness Engine Admin Policy
          
          # Full access to consciousness secrets
          path "consciousness/*" {
            capabilities = ["create", "read", "update", "delete", "list"]
          }
          
          # Database admin
          path "database/*" {
            capabilities = ["create", "read", "update", "delete", "list"]
          }
          
          # PKI admin
          path "pki-internal/*" {
            capabilities = ["create", "read", "update", "delete", "list"]
          }
          
          # Auth methods
          path "auth/*" {
            capabilities = ["create", "read", "update", "delete", "list", "sudo"]
          }
          
          # System admin
          path "sys/*" {
            capabilities = ["create", "read", "update", "delete", "list", "sudo"]
          }
          EOF
          
          vault policy write consciousness-admin /tmp/consciousness-admin-policy.hcl
          
          # Create Kubernetes role for consciousness admins
          vault write auth/kubernetes/role/consciousness-admin \
            bound_service_account_names=consciousness-admin \
            bound_service_account_namespaces=vault \
            policies=consciousness-admin \
            ttl=8h
          
          echo "Vault configuration completed successfully"
          
          # Store initialization data in Kubernetes secret
          kubectl create secret generic vault-init \
            --from-literal=root-token="$ROOT_TOKEN" \
            --from-literal=unseal-key-1="$UNSEAL_KEY_1" \
            --from-literal=unseal-key-2="$UNSEAL_KEY_2" \
            --from-literal=unseal-key-3="$UNSEAL_KEY_3" \
            --from-literal=unseal-key-4="$(cat /tmp/vault-init.json | jq -r '.unseal_keys_b64[3]')" \
            --from-literal=unseal-key-5="$(cat /tmp/vault-init.json | jq -r '.unseal_keys_b64[4]')" \
            -n vault
          
          echo "Vault initialization completed successfully"
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        volumeMounts:
        - name: tmp
          mountPath: /tmp
      volumes:
      - name: tmp
        emptyDir: {}