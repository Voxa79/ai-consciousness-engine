# HashiCorp Vault Deployment for Consciousness Platform
# High Availability setup with auto-unsealing and monitoring

apiVersion: v1
kind: Namespace
metadata:
  name: vault
  labels:
    name: vault
    app: vault

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault
  namespace: vault
  labels:
    app: vault

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: vault-auth-delegator
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:auth-delegator
subjects:
- kind: ServiceAccount
  name: vault
  namespace: vault

---
apiVersion: v1
kind: Secret
metadata:
  name: vault-tls
  namespace: vault
  labels:
    app: vault
type: kubernetes.io/tls
data:
  # These should be replaced with actual certificates
  # Generated with: openssl req -x509 -newkey rsa:4096 -keyout vault.key -out vault.crt -days 365 -nodes
  tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0t...  # Base64 encoded certificate
  tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0t...  # Base64 encoded private key
  ca.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0t...   # Base64 encoded CA certificate

---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: vault-data
  namespace: vault
  labels:
    app: vault
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: fast-ssd

---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: vault
  namespace: vault
  labels:
    app: vault
spec:
  serviceName: vault
  replicas: 3
  selector:
    matchLabels:
      app: vault
  template:
    metadata:
      labels:
        app: vault
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8200"
        prometheus.io/path: "/v1/sys/metrics"
    spec:
      serviceAccountName: vault
      securityContext:
        runAsNonRoot: true
        runAsUser: 100
        runAsGroup: 1000
        fsGroup: 1000
      containers:
      - name: vault
        image: hashicorp/vault:1.15.2
        imagePullPolicy: IfNotPresent
        command:
        - "/bin/sh"
        - "-ec"
        args:
        - |
          cp /vault/config/vault.hcl /tmp/vault.hcl
          sed -i "s/HOSTNAME/$(hostname)/g" /tmp/vault.hcl
          /usr/local/bin/docker-entrypoint.sh vault server -config=/tmp/vault.hcl
        ports:
        - name: http
          containerPort: 8200
          protocol: TCP
        - name: https-internal
          containerPort: 8201
          protocol: TCP
        - name: http-rep
          containerPort: 8202
          protocol: TCP
        env:
        - name: HOSTNAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: VAULT_ADDR
          value: "https://127.0.0.1:8200"
        - name: VAULT_API_ADDR
          value: "https://$(HOSTNAME).vault:8200"
        - name: SKIP_CHOWN
          value: "true"
        - name: SKIP_SETCAP
          value: "true"
        - name: VAULT_CLUSTER_ADDR
          value: "https://$(HOSTNAME).vault:8201"
        - name: VAULT_LOG_LEVEL
          value: "info"
        - name: VAULT_LOG_FORMAT
          value: "json"
        # AWS KMS auto-unsealing (if using AWS)
        - name: AWS_REGION
          value: "us-west-2"
        - name: AWS_ACCESS_KEY_ID
          valueFrom:
            secretKeyRef:
              name: vault-aws-credentials
              key: access-key-id
              optional: true
        - name: AWS_SECRET_ACCESS_KEY
          valueFrom:
            secretKeyRef:
              name: vault-aws-credentials
              key: secret-access-key
              optional: true
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        volumeMounts:
        - name: vault-data
          mountPath: /vault/data
        - name: vault-config
          mountPath: /vault/config
        - name: vault-tls
          mountPath: /vault/tls
        - name: vault-policies
          mountPath: /vault/policies
        - name: vault-init-scripts
          mountPath: /vault/scripts
        livenessProbe:
          httpGet:
            path: "/v1/sys/health?standbyok=true"
            port: 8200
            scheme: HTTPS
          initialDelaySeconds: 60
          periodSeconds: 30
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: "/v1/sys/health?standbyok=true&sealedcode=204&uninitcode=204"
            port: 8200
            scheme: HTTPS
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 3
          failureThreshold: 3
        lifecycle:
          preStop:
            exec:
              command:
              - /bin/sh
              - -c
              - sleep 5 && kill -SIGTERM $(pidof vault)
      - name: vault-unsealer
        image: alpine:3.18
        command:
        - "/bin/sh"
        - "-c"
        args:
        - |
          apk add --no-cache curl jq
          while true; do
            if curl -k -s https://localhost:8200/v1/sys/health | jq -r '.sealed' | grep -q true; then
              echo "Vault is sealed, attempting to unseal..."
              # In production, this would use auto-unsealing with cloud KMS
              # For development, you might store unseal keys in a secure location
            fi
            sleep 30
          done
        env:
        - name: VAULT_ADDR
          value: "https://127.0.0.1:8200"
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"
      volumes:
      - name: vault-config
        configMap:
          name: vault-config
      - name: vault-tls
        secret:
          secretName: vault-tls
      - name: vault-policies
        configMap:
          name: vault-policies
      - name: vault-init-scripts
        configMap:
          name: vault-init-scripts
          defaultMode: 0755
  volumeClaimTemplates:
  - metadata:
      name: vault-data
    spec:
      accessModes:
        - ReadWriteOnce
      resources:
        requests:
          storage: 10Gi
      storageClassName: fast-ssd

---
apiVersion: v1
kind: Service
metadata:
  name: vault
  namespace: vault
  labels:
    app: vault
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "8200"
    prometheus.io/path: "/v1/sys/metrics"
spec:
  type: ClusterIP
  ports:
  - name: http
    port: 8200
    targetPort: 8200
    protocol: TCP
  - name: https-internal
    port: 8201
    targetPort: 8201
    protocol: TCP
  selector:
    app: vault

---
apiVersion: v1
kind: Service
metadata:
  name: vault-headless
  namespace: vault
  labels:
    app: vault
spec:
  clusterIP: None
  ports:
  - name: http
    port: 8200
    targetPort: 8200
    protocol: TCP
  - name: https-internal
    port: 8201
    targetPort: 8201
    protocol: TCP
  selector:
    app: vault

---
apiVersion: v1
kind: Service
metadata:
  name: vault-ui
  namespace: vault
  labels:
    app: vault
    component: ui
spec:
  type: LoadBalancer
  ports:
  - name: http
    port: 8200
    targetPort: 8200
    protocol: TCP
  selector:
    app: vault

---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: vault-ingress
  namespace: vault
  labels:
    app: vault
  annotations:
    kubernetes.io/ingress.class: "nginx"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
    nginx.ingress.kubernetes.io/proxy-body-size: "1m"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
  - hosts:
    - vault.consciousness.ai
    secretName: vault-tls-ingress
  rules:
  - host: vault.consciousness.ai
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: vault
            port:
              number: 8200

---
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: vault-pdb
  namespace: vault
  labels:
    app: vault
spec:
  maxUnavailable: 1
  selector:
    matchLabels:
      app: vault

---
apiVersion: v1
kind: Secret
metadata:
  name: vault-aws-credentials
  namespace: vault
  labels:
    app: vault
type: Opaque
data:
  # These should be replaced with actual AWS credentials for KMS auto-unsealing
  # Only needed if using AWS KMS for auto-unsealing
  access-key-id: ""     # Base64 encoded AWS access key ID
  secret-access-key: "" # Base64 encoded AWS secret access key

---
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: vault
  namespace: vault
  labels:
    app: vault
spec:
  selector:
    matchLabels:
      app: vault
  endpoints:
  - port: http
    path: /v1/sys/metrics
    params:
      format: ['prometheus']
    scheme: https
    tlsConfig:
      insecureSkipVerify: true
    interval: 30s
    scrapeTimeout: 10s